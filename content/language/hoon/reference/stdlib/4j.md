# 4j: Parsing (Bases and Base Digits) {#4j-parsing-bases-and-base-digits}

## `++ab` {#ab}

Primitive parser engine

A core containing numeric parser primitives.

#### Source {#source}

```hoon
++  ab
  |%
```

#### Examples {#examples}

```
> ab
<36.ecc 414.gly 100.xkc 1.ypj %164>
```

---

### `++bix:ab` {#bixab}

Parse hex pair

Parsing `rule`. Parses a pair of base-16 digits. Used in escapes.

#### Source {#source}

```hoon
++  bix  (bass 16 (stun [2 2] six))
```

#### Examples {#examples}

```
> (scan "07" bix:ab)
7
> (scan "51" bix:ab)
81
> (scan "a3" bix:ab)
163
```

---

### `++fem:ab` {#femab}

Parse base58check char

Parse a single base58check character.

#### Source {#source}

```hoon
++  fem  (sear |=(a=@ (cha:fa a)) aln)
```

#### Examples {#examples}

```
> (scan "6" fem:ab)
5

> (scan "Z" fem:ab)
32

> (scan "j" fem:ab)
42
```

---

### `++haf:ab` {#hafab}

Parse non-doz phonetic pair

Parsing `rule`. Parses an atom of aura `@pE`, a phrase of two bytes encoded phonetically. If the leading syllable is `doz` (`0`), parsing will fail.

#### Source {#source}

```hoon
++  haf  (bass 256 ;~(plug tep tiq (easy ~)))
```

#### Examples {#examples}

```
> `@p`(scan "sampel" haf:ab)
~sampel

> `@p`(scan "dozpel" haf:ab)
{1 4}
syntax error
```

---

### `++hef:ab` {#hefab}

Parse non-dozzod phonetic pair

Parsing `rule`. Parses an atom of aura `@pE` without leading `~` or `.~`, a phrase of two bytes encoded phonetically. If it's `dozzod`, parsing will fail.

#### Source {#source}

```hoon
++  hef  %+  sear  |=(a=@ ?:(=(a 0) ~ (some a)))
         %+  bass  256
         ;~(plug tip tiq (easy ~))
```

#### Examples {#examples}

```
> `@p`(scan "sampel" hef:ab)
~sampel

> `@p`(scan "dozpel" hef:ab)
~pel

> `@p`(scan "dozzod" hef:ab)
{1 7}
syntax error
```

---

### `++hif:ab` {#hifab}

Parse phonetic pair

Parsing `rule`. Parses an atom of aura `@pE`, without leading `~` or `.~`. A phrase of two bytes encoded phonetically.

#### Source {#source}

```hoon
++  hif  (boss 256 ;~(plug tip tiq (easy ~)))
```

#### Examples {#examples}

```
> `@p`(scan "doznec" hif:ab)
~nec

> `@p`(scan "pittyp" hif:ab)
~pittyp
```

---

### `++hof:ab` {#hofab}

Parse 2-4 @q phonetic pairs

Parsing `rule`. Parses an atom of aura `@q` (non-scrambled `@p`), without leading `~` or `.~`, of between two and four phrases.

#### Source {#source}

```hoon
++  hof  (bass 0x1.0000 ;~(plug hef (stun [1 3] ;~(pfix hep hif))))
```

#### Example {#example}

```
> `@q`(scan "sampel-palnet" hof:ab)
.~sampel-palnet

> `@q`(scan "sampel-sampel-palnet" hof:ab)
.~sampel-sampel-palnet

> `@q`(scan "sampel-sampel-sampel-palnet" hof:ab)
.~sampel-sampel-sampel-palnet
```

---

### `++huf:ab` {#hufab}

Parse 1-4 @q phonetic pairs

Parsing `rule`. Parses an atom of aura `@q` (non-scrambled `@p`), without leading `~` or `.~`, of between one and four phrases.

#### Source {#source}

```hoon
++  huf  (bass 0x1.0000 ;~(plug hef (stun [0 3] ;~(pfix hep hif))))
```

#### Examples {#examples}

```
> `@q`(scan "sampel" huf:ab)
.~sampel

> `@q`(scan "sampel-palnet" huf:ab)
.~sampel-palnet

> `@q`(scan "sampel-sampel-palnet" huf:ab)
.~sampel-sampel-palnet

> `@q`(scan "sampel-sampel-sampel-palnet" huf:ab)
.~sampel-sampel-sampel-palnet
```

---

### `++hyf:ab` {#hyfab}

Parse four @q phonetic pairs

Parsing `rule`. Parses an atom of aura `@q` (non-scrambled `@p`), without leading `~` or `.~`, of exactly four phrases.

#### Source {#source}

```hoon
++  hyf  (bass 0x1.0000 ;~(plug hif (stun [3 3] ;~(pfix hep hif))))
```

#### Examples {#examples}

```
> `@q`(scan "sampel-sampel-sampel-palnet" hyf:ab)
.~sampel-sampel-sampel-palnet
```

---

### `++pev:ab` {#pevab}

Parse 1-5 @uv base-32 chars

Parsing `rule`. Parses one to five `@uv` base-32 digits without the leading `0v` or leading zeros.

#### Source {#source}

```hoon
++  pev  (bass 32 ;~(plug sev (stun [0 4] siv)))
```

#### Examples {#examples}

```
> `@uv`(scan "du3ja" pev:ab)
0vdu3ja

> `@uv`(scan "3ja" pev:ab)
0v3ja

> `@uv`(scan "a" pev:ab)
0va
```

---

### `++pew:ab` {#pewab}

Parse 1-5 @uw base-64 chars

Parsing `rule`. Parses one to five `@uw` base-64 digits without the leading `0w` or leading zeros.

#### Source {#source}

```hoon
++  pew  (bass 64 ;~(plug sew (stun [0 4] siw)))
```

#### Examples {#examples}

```
> `@uw`(scan "6U0gP" pew:ab)
0w6U0gP

> `@uw`(scan "gP" pew:ab)
0wgP

> `@uw`(scan "P" pew:ab)
0wP
```

---

### `++piv:ab` {#pivab}

Parse 5 @uv base-32 chars

Parsing `rule`. Parses exactly five `@uv` base-32 digits without the leading `0v` or leading zeros.

#### Source {#source}

```hoon
++  piv  (bass 32 (stun [5 5] siv))
```

#### Examples {#examples}

```
> `@uv`(scan "du3ja" piv:ab)
0vdu3ja

> `@uv`(scan "u3ja" piv:ab)
{1 5}
syntax error
```

---

### `++piw:ab` {#piwab}

Parse 5 @uw base-64 chars

Parsing `rule`. Parses exactly five `@uw` base-64 digits without the leading `0w` or leading zeros.

#### Source {#source}

```hoon
++  piw  (bass 64 (stun [5 5] siw))
```

#### Examples {#examples}

```
> `@uw`(scan "6U0gP" piw:ab)
0w6U0gP

> `@uw`(scan "U0gP" piw:ab)
{1 5}
syntax error
```

---

### `++qeb:ab` {#qebab}

Parse 1-4 binary digits

Parsing `rule`. Parses a binary number of up to 4 digits in length without a leading zero.

#### Source {#source}

```hoon
++  qeb  (bass 2 ;~(plug seb (stun [0 3] sib)))
```

#### Examples {#examples}

```
> `@ub`(scan "1010" qeb:ab)
0b1010

> `@ub`(scan "10" qeb:ab)
0b10

> `@ub`(scan "1" qeb:ab)
0b1

> `@ub`(scan "0" qeb:ab)
{1 1}
syntax error
```

---

### `++qex:ab` {#qexab}

Parse 1-4 hex digits

Parsing `rule`. Parses a hexadecimal number of up to 4 digits in length without a leading zero.

#### Source {#source}

```hoon
++  qex  (bass 16 ;~(plug sex (stun [0 3] hit)))
```

#### Examples {#examples}

```
> `@ux`(scan "beef" qex:ab)
0xbeef

> `@ux`(scan "ef" qex:ab)
0xef

> `@ux`(scan "f" qex:ab)
0xf
```

---

### `++qib:ab` {#qibab}

Parse 4 binary

Parsing `rule`. Parses exactly four binary digits - may have leading zeros.

#### Source {#source}

```hoon
++  qib  (bass 2 (stun [4 4] sib))
```

#### Examples {#examples}

```
> `@ub`(scan "0001" qib:ab)
0b1

> `@ub`(scan "1001" qib:ab)
0b1001

> `@ub`(scan "1" qib:ab)
{1 2}
syntax error
```

---

### `++qix:ab` {#qixab}

Parse 4 hex

Parsing `rule`. Parses exactly four hexadecimal digits - may have leading zeros.

#### Source {#source}

```hoon
++  qix  (bass 16 (stun [4 4] six))
```

#### Examples {#examples}

```
> `@ux`(scan "beef" qix:ab)
0xbeef

> `@ux`(scan "0000" qix:ab)
0x0

> `@ux`(scan "ef" qix:ab)
{1 3}
syntax error
```

---

### `++seb:ab` {#sebab}

Parse 1

Parsing `rule`. Parses the number 1.

#### Source {#source}

```hoon
++  seb  (cold 1 (just '1'))
```

#### Examples {#examples}

```
> (scan "1" seb:ab)
1

> (scan "2" seb:ab)
{1 1}
syntax error
```

---

### `++sed:ab` {#sedab}

Parse decimal

Parsing `rule`. Parses a nonzero decimal digit.

#### Source {#source}

```hoon
++  sed  (cook |=(a=@ (sub a '0')) (shim '1' '9'))
```

#### Examples {#examples}

```
> (scan "5" sed:ab)
5

> (scan "0" sed:ab)
{1 1}
syntax error
```

---

### `++sev:ab` {#sevab}

Parse base-32

Parsing `rule`. Parses a nonzero base-32 digit.

#### Source {#source}

```hoon
++  sev  ;~(pose sed sov)
```

#### Examples {#examples}

```
> `@uv`(scan "2" sev:ab)
0v2

> `@uv`(scan "j" sev:ab)
0vj

> `@uv`(scan "0" sev:ab)
{1 1}
syntax error
```

---

### `++sew:ab` {#sewab}

Parse base-64

Parsing `rule`. Parses a nonzero base-64 digit.

#### Source {#source}

```hoon
++  sew  ;~(pose sed sow)
```

#### Examples {#examples}

```
> `@uw`(scan "I" sew:ab)
0wI

> `@uw`(scan "2" sew:ab)
0w2

> `@uw`(scan "0" sew:ab)
{1 1}
syntax error
```

---

### `++sex:ab` {#sexab}

Parse hex

Parsing `rule`. Parses a non-zero hexadecimal digit.

#### Source {#source}

```hoon
++  sex  ;~(pose sed sox)
```

#### Examples {#examples}

```
> `@ux`(scan "a" sex:ab)
0xa

> `@ux`(scan "2" sex:ab)
0x2

> `@ux`(scan "0" sex:ab)
{1 1}
syntax error
```

---

### `++sib:ab` {#sibab}

Parse binary

Parsing `rule`. Parses a binary digit.

#### Source {#source}

```hoon
++  sib  (cook |=(a=@ (sub a '0')) (shim '0' '1'))
```

#### Examples {#examples}

```
> `@ub`(scan "1" sib:ab)
0b1

> `@ub`(scan "0" sib:ab)
0b0
```

---

### `++sid:ab` {#sidab}

Parse decimal

Parsing `rule`. Parses a decimal digit.

#### Source {#source}

```hoon
++  sid  (cook |=(a=@ (sub a '0')) (shim '0' '9'))
```

#### Examples {#examples}

```
> (scan "5" sid:ab)
5

> (scan "0" sid:ab)
0
```

---

### `++siv:ab` {#sivab}

Parse base-32

Parsing `rule`. Parses a base-32 digit.

#### Source {#source}

```hoon
++  siv  ;~(pose sid sov)
```

#### Examples {#examples}

```
> `@uv`(scan "r" siv:ab)
0vr

> `@uv`(scan "5" siv:ab)
0v5

> `@uv`(scan "0" siv:ab)
0v0
```

---

### `++siw:ab` {#siwab}

Parse base-64

Parsing `rule`. Parses a base-64 digit.

#### Source {#source}

```hoon
++  siw  ;~(pose sid sow)
```

#### Examples {#examples}

```
> `@uw`(scan "M" siw:ab)
0wM

> `@uw`(scan "0" siw:ab)
0w0

> `@uw`(scan "c" siw:ab)
0wc
```

---

### `++six:ab` {#sixab}

Parse hex

Parsing `rule`. Parses a hexadecimal digit.

#### Source {#source}

```hoon
++  six  ;~(pose sid sox)
```

#### Examples {#examples}

```
> `@ux`(scan "e" six:ab)
0xe

> `@ux`(scan "0" six:ab)
0x0
```

---

### `++sov:ab` {#sovab}

Parse @uv base-32 letter

Parsing `rule`. Parses a `@uv` base-32 letter (but not a number).

#### Source {#source}

```hoon
++  sov  (cook |=(a=@ (sub a 87)) (shim 'a' 'v'))
```

#### Examples {#examples}

```
> `@uv`(scan "c" sov:ab)
0vc

> `@uv`(scan "j" sov:ab)
0vj

> `@uv`(scan "5" sov:ab)
{1 1}
syntax error
```

---

### `++sow:ab` {#sowab}

Parse @uw base-64 letter/symbol

Parsing `rule`. Parses a base-64 letter/symbol (but not number).

#### Source {#source}

```hoon
++  sow  ;~  pose
           (cook |=(a=@ (sub a 87)) (shim 'a' 'z'))
           (cook |=(a=@ (sub a 29)) (shim 'A' 'Z'))
           (cold 62 (just '-'))
           (cold 63 (just '~'))
         ==
```

#### Examples {#examples}

```
> `@uw`(scan "M" sow:ab)
0wM

> `@uw`(scan "5" sow:ab)
{1 1}
syntax error
```

---

### `++sox:ab` {#soxab}

Parse hex letter

Parsing `rule`. Parses a hexadecimal letter (but not number).

#### Source {#source}

```hoon
++  sox  (cook |=(a=@ (sub a 87)) (shim 'a' 'f'))
```

#### Examples {#examples}

```
> `@ux`(scan "e" sox:ab)
0xe

> `@ux`(scan "5" sox:ab)
{1 1}
syntax error
```

---

### `++ted:ab` {#tedab}

Parse 1-999 decimal

Parsing `rule`. Parses a decimal number of up to 3 digits without a leading zero.

#### Source {#source}

```hoon
++  ted  (bass 10 ;~(plug sed (stun [0 2] sid)))
```

#### Examples {#examples}

```
> (scan "214" ted:ab)
214

> (scan "2" ted:ab)
2

> (scan "2161" ted:ab)
{1 4}
syntax error
```

---

### `++tep:ab` {#tepab}

Parse non-doz leading phonetic byte

Parsing `rule`. Parses the leading phonetic byte , which represents a syllable. Fails if it is `doz`.

#### Source {#source}

```hoon
++  tep  (sear |=(a=@ ?:(=(a 'doz') ~ (ins:po a))) til)
```

#### Examples {#examples}

```
> (scan "sam" tep:ab)
4

> (scan "wic" tep:ab)
99
```

---

### `++tip:ab` {#tipab}

Leading phonetic byte

Parsing `rule`. Parses the leading phonetic byte, which represents a syllable.

#### Source {#source}

```hoon
++  tip  (sear |=(a=@ (ins:po a)) til)
```

#### Examples {#examples}

```
> (scan "doz" tip:ab)
0

> (scan "pit" tip:ab)
242
```

---

### `++tiq:ab` {#tiqab}

Trailing phonetic syllable

Parsing `rule`. Parses the trailing phonetic byte, which represents a syllable.

#### Source {#source}

```hoon
++  tiq  (sear |=(a=@ (ind:po a)) til)
```

#### Examples {#examples}

```
> (scan "zod" tiq:ab)
0
> (scan "nec" tiq:ab)
1
```

---

### `++tid:ab` {#tidab}

Parse 3 decimal digits

Parsing `rule`. Parses exactly three decimal digits.

#### Source {#source}

```hoon
++  tid  (bass 10 (stun [3 3] sid))
```

#### Examples {#examples}

```
> (scan "013" tid:ab)
13

> (scan "999" tid:ab)
999

> (scan "99" tid:ab)
{1 3}
syntax error
```

---

### `++til:ab` {#tilab}

Parse 3 lowercase

Parsing `rule`. Parses exactly three lowercase letters.

#### Source {#source}

```hoon
++  til  (boss 256 (stun [3 3] low))
```

#### Examples {#examples}

```
> `@t`(scan "mer" til:ab)
'mer'

> `@t`(scan "me" til:ab)
{1 3}
syntax error
```

---

### `++urs:ab` {#ursab}

Parse knot characters

Parsing rule. Parses characters from an atom of the knot aura `@ta`.

#### Source {#source}

```hoon
++  urs  %+  cook
           |=(a=tape (rap 3 ^-((list @) a)))
         (star ;~(pose nud low hep dot sig cab))
```

#### Examples {#examples}

```
> `@ta`(scan "asa-lom_tak" urs:ab)
~.asa-lom_tak
```

---

### `++urt:ab` {#urtab}

Parse knot without underscores

Parsing `rule`. Parses all characters of the knot aura `@ta` except for cab, `_`.

#### Source {#source}

```hoon
++  urt  %+  cook
           |=(a=tape (rap 3 ^-((list @) a)))
         (star ;~(pose nud low hep dot sig))
```

#### Examples {#examples}

```
> `@ta`(scan "asa-lom.t0k" urt:ab)
~.asa-lom.t0k
```

---

### `++voy:ab` {#voyab}

Parse bas, soq, or bix

Parsing `rule`. Parses an escaped backslash, single quote, or hex pair byte.

#### Source {#source}

```hoon
++  voy  ;~(pfix bas ;~(pose bas soq bix))
```

#### Examples {#examples}

```
> (scan "\\\\" voy:ab)
'\\'

> (scan "\\'" voy:ab)
'\''

> (scan "\\0a" voy:ab)
'\0a'
```

---

## `++ag` {#ag}

Top-level atom parser engine

A core containing top-level atom parsers.

#### Source {#source}

```hoon
++  ag
  |%
```

---

### `++ape:ag` {#apeag}

Parse 0 or rule

Parser modifier. Parses 0 or the sample rule `fel`.

#### Accepts {#accepts}

`fel` is a `rule`.

#### Produces {#produces}

A `rule`.

#### Source {#source}

```hoon
++  ape  |*(fel=rule ;~(pose (cold 0 (just '0')) fel))
```

#### Examples {#examples}

```
> (scan "0" (ape:ag (cold 2 (just '2'))))
0

> (scan "2" (ape:ag (cold 2 (just '2'))))
2

> (scan "3" (ape:ag (cold 2 (just '2'))))
{1 1}
syntax error
```

---

### `++bay:ag` {#bayag}

Parses binary number

Parsing `rule`. Parses a binary number without a leading zero.

#### Source {#source}

```hoon
++  bay  (ape (bass 16 ;~(plug qeb:ab (star ;~(pfix dog qib:ab)))))
```

#### Examples {#examples}

```
> `@ub`(scan "101.1100.0011.1010" bay:ag)
0b101.1100.0011.1010
```

---

### `++bip:ag` {#bipag}

Parse IPv6

Parsing rule. Parses a `@is`, an IPv6 address.

#### Source {#source}

```hoon
++  bip  =+  tod=(ape qex:ab)
         (bass 0x1.0000 ;~(plug tod (stun [7 7] ;~(pfix dog tod))))
```

#### Examples {#examples}

```
> `@is`(scan "0.0.ea.3e6c.0.0.0.0" bip:ag)
.0.0.ea.3e6c.0.0.0.0
```

---

### `++dem:ag` {#demag}

Parse decimal with dots

Parsing `rule`. Parses a decimal number that includes dot separators.

#### Source {#source}

```hoon
++  dem  (ape (bass 1.000 ;~(plug ted:ab (star ;~(pfix dog tid:ab)))))
```

#### Examples {#examples}

```
> (scan "52" dem:ag)
52
> (scan "13.507" dem:ag)
13.507
```

---

### `++dim:ag` {#dimag}

Parse decimal number

Parsing rule. Parses a decimal number without a leading zero.

#### Source {#source}

```hoon
++  dim  (ape dip)
```

#### Examples {#examples}

```
> (scan "52" dim:ag)
52

> (scan "0" dim:ag)
0

> (scan "13507" dim:ag)
13.507

> (scan "013507" dim:ag)
{1 2}
syntax error
```

---

### `++dum:ag` {#dumag}

Parse decimal with leading `0`

Parsing rule. Parses a decmial number with leading zeroes.

#### Source {#source}

```hoon
++  dum  (bass 10 (plus sid:ab))
```

#### Examples {#examples}

```
> (scan "52" dum:ag)
52
> (scan "0000052" dum:ag)
52
> (scan "13507" dim:ag)
13.507
```

---

### `++fed:ag` {#fedag}

Parse phonetic base

Parsing rule. Parses an atom of aura `@p`, the phonetic base.

#### Source {#source}

```hoon
++  fed  %+  cook  fynd:ob
         ;~  pose
           %+  bass  0x1.0000.0000.0000.0000          ::  oversized
             ;~  plug
               huf:ab
               (plus ;~(pfix doh hyf:ab))
             ==
           hof:ab                                     ::  planet or moon
           haf:ab                                     ::  star
           tiq:ab                                     ::  galaxy
         ==
```

#### Examples {#examples}

```
> `@p`(scan "zod" fed:ag)
~zod

> `@p`(scan "sampel" fed:ag)
~sampel

> `@p`(scan "sampel-palnet" fed:ag)
~sampel-palnet

> `@p`(scan "sampel-palnet-sampel-palnet" fed:ag)
~sampel-palnet-sampel-palnet

> `@p`(scan "tillyn-nillyt-tasfyn-partyv--novweb-talrud-talmud-sonfyr" fed:ag)
~tillyn-nillyt-tasfyn-partyv--novweb-talrud-talmud-sonfyr
```

---

### `++feq:ag` {#feqag}

Parse `@q` phonetic base

Parsing rule. Parses an atom of aura `@q` (an unscrambled `@p`).

#### Source {#source}

```hoon
++  feq  %+  cook  |=(a=(list @) (rep 4 (flop a)))
         ;~  plug
           ;~(pose hif:ab tiq:ab)
           (star ;~(pfix dof hif:ab))
         ==
```

#### Examples {#examples}

```
> `@q`(scan "sampel" feq:ag)
.~sampel

> `@q`(scan "sampel-palnet" feq:ag)
.~sampel-palnet

> `@q`(scan "sampel-sampel-palnet" feq:ag)
.~sampel-sampel-palnet

> `@q`(scan "sampel-palnet-sampel-palnet" feq:ag)
.~sampel-palnet-sampel-palnet

> `@q`(scan "sampel-sampel-sampel-sampel-palnet-sampel-palnet" feq:ag)
.~sampel-sampel-sampel-sampel-palnet-sampel-palnet
```

---

### `++fim:ag` {#fimag}

Parse base58check

Parse a base58check value, check checksum, and return decoded value sans-checksum. If the checksum check fails, parsing will fail.

#### Source {#source}

```hoon
++  fim  (sear den:fa (bass 58 (plus fem:ab)))
```

#### Examples {#examples}

With valid checksum:

```
> (enc:fa 0xdead.beef)
0xdead.beef.938b.8b0c
> (c-co:co 0xdead.beef.938b.8b0c)
"eFGDJSVvRHd"
> `@ux`(scan "eFGDJSVvRHd" fim:ag)
0xdead.beef
```

With invalid checksum:

```
> (c-co:co 0xdead.beef.ffff)
"2utUWE41U"
> `@ux`(scan "2utUWE41U" fim:ag)
{1 10}
syntax error
```

---

### `++hex:ag` {#hexag}

Parse hex

Parsing `rule`. Parses a hexadecimal number

#### Source {#source}

```hoon
++  hex  (ape (bass 0x1.0000 ;~(plug qex:ab (star ;~(pfix dog qix:ab)))))
```

#### Examples {#examples}

```
> `@ux`(scan "4" hex:ag)
0x4

> `@ux`(scan "1a" hex:ag)
0x1a

> `@ux`(scan "3.ac8d" hex:ag)
0x3.ac8d
```

---

### `++lip:ag` {#lipag}

Parse IPv4 address

Parsing `rule`. Parses an IPv4 address.

#### Source {#source}

```hoon
++  lip  =+  tod=(ape ted:ab)
         (bass 256 ;~(plug tod (stun [3 3] ;~(pfix dog tod))))
```

#### Examples {#examples}

```
> `@if`(scan "127.0.0.1" lip:ag)
.127.0.0.1
```

---

### `++mot:ag` {#motag}

Parse numerical month

Parse a numerical month (1-12).

#### Source {#source}

```hoon
++  mot  ;~  pose
           ;~  pfix
             (just '1')
             (cook |=(a=@ (add 10 (sub a '0'))) (shim '0' '2'))
           ==
           sed:ab
         ==
```

#### Examples {#examples}

```
> (scan "0" mot:ag)
{1 1}
syntax error

> (scan "1" mot:ag)
1

> (scan "6" mot:ag)
6

> (scan "12" mot:ag)
12

> (scan "13" mot:ag)
{1 2}
syntax error
```

---

### `++viz:ag` {#vizag}

Parse Base-32 with dots

Parsing `rule`. Parses a Base-32 number with dot separators.

#### Source {#source}

```hoon
++  viz  (ape (bass 0x200.0000 ;~(plug pev:ab (star ;~(pfix dog piv:ab)))))
```

#### Examples {#examples}

```
> `@uv`(scan "e2.ol4pm" viz:ag)
0ve2.ol4pm
```

---

### `++vum:ag` {#vumag}

Parse base-32 string

Parsing `rule`. Parses a raw base-32 string (without dots).

#### Source {#source}

```hoon
++  vum  (bass 32 (plus siv:ab))
```

#### Examples {#examples}

```
> `@uv`(scan "e2ol4pm" vum:ag)
0ve2.ol4pm
```

---

### `++wiz:ag` {#wizag}

Parse base-64

Parsing `rule`. Parses a base-64 number.

#### Source {#source}

```hoon
++  wiz  (ape (bass 0x4000.0000 ;~(plug pew:ab (star ;~(pfix dog piw:ab)))))
```

#### Examples {#examples}

```
> `@uw`(scan "e2O.l4Xpm" wiz:ag)
0we2O.l4Xpm
```

---

## `++mu` {#mu}

Core used to scramble 16-bit atoms

A door that contains arms that are used to scramble two atoms, `top` and `bot`. Used especially in the phonetic base to disguise the relationship between a planet and its star.

#### Accepts {#accepts}

`top` is an atom.

`bot` is an atom.

#### Source {#source}

```hoon
++  mu
  |_  [top=@ bot=@]
```

---

### `++zag:mu` {#zagmu}

Add bottom into top

Produces the cell of `top` and `bot` with `top` scrambled to the result of adding `bot` to `top` modulo 16. Used to scramble the name of a planet.

#### Accepts {#accepts}

`top` & `bot` are atoms, and are the sample of `+mu`.

#### Produces {#produces}

A `(pair @ @)`.

#### Source {#source}

```hoon
++  zag  [p=(end 4 (add top bot)) q=bot]
```

#### Examples {#examples}

```
> `[@ux @ux]`~(zag mu 0x20e0 0x201)
[0x22e1 0x201]
```

---

### `++zig:mu` {#zigmu}

Subtract bottom from top

The inverse of [`++zag`](#zagmu). Produces the cell of `top` and `bot` with `top` unscrambled. The unscrambled `top` is the sum of the sample `top` and the 16-bit complement of `bot`. Used to unscramble the name of the planet.

#### Accepts {#accepts}

`top` & `bot` are atoms, and are the sample of `+mu`.

#### Produces {#produces}

A `(pair @ @)`.

#### Source {#source}

```hoon
++  zig  [p=(end 4 (add top (sub 0x1.0000 bot))) q=bot]
```

#### Examples {#examples}

```
> `[@ux @ux]`~(zig mu 0x22e1 0x201)
[0x20e0 0x201]
```

---

### `++zug:mu` {#zugmu}

Concatenate into atom

Produces the concatenation of `top` and `bot`. Used to assemble a planet name.

#### Accepts {#accepts}

`top` & `bot` are atoms, and are the sample of `+mu`.

#### Produces {#produces}

An atom.

#### Source {#source}

```hoon
++  zug  (mix (lsh 4 top) bot)
```

#### Examples {#examples}

```
> `@ux`~(zug mu 0x22e1 0x201)
0x22e1.0201
```

---

## `++ne` {#ne}

Digit rendering engine

A door containing arms that render digits at bases 10, 16, 32, and 64.

#### Accepts {#accepts}

`tig` is an `atom`.

#### Source {#source}

```hoon
++  ne
  |_  tig=@
```

---

### `++c:ne` {#cne}

Render base58check

Render a single base58check character.

#### Accepts {#accepts}

`tig` is an `atom`, and is the sample of `+ne`.

#### Produces {#produces}

An atom.

#### Source {#source}

```hoon
++  c  (cut 3 [tig 1] key:fa)
```

#### Examples {#examples}

```
> `@t`~(c ne 7)
'8'

> `@t`~(c ne 27)
'U'

> `@t`~(c ne 57)
'z'

> `@t`~(c ne 58)
''
```

---

### `++d:ne` {#dne}

Render decimal

Renders a decimal digit as an atom of an ACII byte value.

#### Accepts {#accepts}

`tig` is an `atom`, and is the sample of `+ne`.

#### Produces {#produces}

An atom.

#### Source {#source}

```hoon
++  d  (add tig '0')
```

#### Examples {#examples}

```
> `@t`~(d ne 7)
'7'
```

---

### `++x:ne` {#xne}

Render hex

Renders a hexadecimal digit as an atom of an ASCII byte value.

#### Accepts {#accepts}

`tig` is an `atom`, and is the sample of `+ne`.

#### Produces {#produces}

An atom.

#### Source {#source}

```hoon
++  x  ?:((gte tig 10) (add tig 87) d)
```

#### Examples {#examples}

```
> `@t`~(x ne 7)
'7'

> `@t`~(x ne 14)
'e'
```

---

### `++v:ne` {#vne}

Render base-32

Renders a base-32 digit as an atom of an ASCII byte value.

#### Accepts {#accepts}

`tig` is an `atom`, and is the sample of `+ne`.

#### Produces {#produces}

An atom.

#### Source {#source}

```hoon
++  v  ?:((gte tig 10) (add tig 87) d)
```

#### Examples {#examples}

```
> `@t`~(v ne 7)
'7'

> `@t`~(v ne 14)
'e'

> `@t`~(v ne 25)
'p'
```

---

### `++w:ne` {#wne}

Render base-64

Renders a base-64 digit as an atom of an ASCII byte value.

#### Accepts {#accepts}

`tig` is an `atom`, and is the sample of `+ne`.

#### Produces {#produces}

An atom.

#### Source {#source}

```hoon
++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))
```

#### Examples {#examples}

```
> `@t`~(w ne 7)
'7'

> `@t`~(w ne 14)
'e'

> `@t`~(w ne 25)
'p'

> `@t`~(w ne 52)
'Q'

> `@t`~(w ne 61)
'Z'

> `@t`~(w ne 63)
'~'

> `@t`~(w ne 62)
'-'
```

---
